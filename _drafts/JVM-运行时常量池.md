## 常量池
### 运行时常量池 VS 常量池
- 方法区：运行时常量池
- 常量池：字节码文件： Constant Pool

存储符号引用，字面量，方法名，参数类型

- 运行时常量池 是方法区的一部分
- 常量池表 是Class 文件的一部分，**用于存放编译器生成的各种字面量和符号引用**， 这部分内容将在类加载后存放到方法区的运行时常量池中

- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池
- JVM 为每个已加载的类型(类或接口) 都会维护一个常量池。池中的数据项像素组一样，是通过索引访问的
- 运行时常量池中包含多种不同常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实的地址
  - 运行时常量池，相对Class文件中的常量池的另一重要特征是：具备动态性

- 运行时常量池类似于传统编程语言中的符号表(Symbol table), 但是它所包含的数据却比符号表要更丰富一些
- 当创建类或接口的运行时常量池时, 如果构造运行时常量池所需的内存空间超过了方法区所提供的最大值, JVM则会抛出OOM 异常


## StringTable

jdk7 StringTable 放到堆空间中，永久代回收效率低，在full GC时才会回收
开发中有大量 字符串被创建，放到堆里， 回收效率高


## 方法区垃圾收集
- 判断一个常量是否**废弃**，还是相对简单
- 判断一个类是否属于**不再使用的类** 比较苛刻
  - 该类的所有实例被回收: java堆中不存在该类及任何派生子类的实例
  - 加载该类的类加载器被回收，这个条件除非时经过精心设计的可替换类加载器的场景：OSGi, JSP的重加载，否则通常很难达成
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法


- 方法区很难回收，费力不讨好，虚拟机规范也没有明确规定，可以回收，也可以不回收  