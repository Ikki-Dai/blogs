## 动态内存分配
- 垃圾收集: Lisp语言就有了

#### 什么是垃圾
- 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
- 如果不对内存中的垃圾进行及时清理， 那么这些垃圾对象所占用的空间会一直保留到应用程序结束，保留的空间无法被其他对象使用，甚至导致内存溢出


## 垃圾回收算法

### 标记阶段

- 在堆里存放着几乎所有的对象实例，在GC 之前，先需要分析内存中哪写对象存活，哪写死亡。只有被标记为已经死亡的对象，GC才会执行垃圾回收时，释放其占用空间，这个过程被称为垃圾标记阶段

- 当一个对象不被任何存活对象继续引用时，宣判死亡

- 一半又两种方式 : 应用计数法，和可达性分析算法

##### 引用计数法

- 每个对象保存一个整型引用计数器属性，记录被引用情况
- 实现简单，垃圾对象便于识别，判定效率高，回收没有延迟性
- 需要单独的存储字段，额外空间开销； 计数器需要跟新，伴随加法减法操作，增加时间开销; 无法处理循环引用的情况 (java 不使用这个算法)

- 其他语言使用了：python, 使用weakref 解决循环引用缺点


##### 可达性分析算法

- 具备实现简单和执行高效， 能解决 循环引用的问题
- 追踪性垃圾收集

- 从GC Roots 为起始，从上至下的方式搜索被根对象连接的对象是否可达
  - 栈中对象: 参数，局部变量
  - JNI 引用的对象
  - java 类的引用静态变量
  - StringTable
  - synchronized 对象
  - 基本数据类型对应得Class 对象，常驻异常对象(NPE, OOM), 类加载器
  - JMXBean, JVMTI 中注册得回调, 本地代码缓存等

^^^ 自己没有放到堆中的对象

- 分析工作必须在一个保障一致性的快照中进行： "StopTheWorld", 即使在号称不会发生停顿的 CMS 中，在枚举GC Roots 时也会发生停顿


### 对象的 Finalization 机制

##### 

- 永远不要主动调用 `finalize()` 方法
  - 可能导致对象复活
  - 执行时间没有保证，由GC 线程决定, 极端情况下，不发生GC ，该方法没有执行机会
  - 糟糕的finalize 方法验证影响GC 性能
- 和 C++ 析构函数相似

- 有三种状态:
  - 可触及的: 从根节点开始，可以达到这个对象
  - 可复活的: 对象的引用都被释放, 但是对象可能在 `finalize()` 中复活
  - 不可触及的: 对象的`finalize()` 被调用，没有复活, 进入不可触及的状态，不可能再次复活， 应为 `finalize()` 只会被调用一次

##### 具体过程
1. 如果对象没有 GC Roots 没有引用链, 则进行第一次标记
2. 如果进行筛选，判断此对象是否必要执行 `finalize()`  方法
  - 如果没有重写，或者已被调用过，则"没必要执行"，对象判定为不可触及的
  - 如果重写了方法，未被执行过， 会被插入到 F-Queue 队列中，一个由虚拟机创建的、低优先级的Finalizer 线程触发其 finalize() 方法执行
  - `finalize()` 方法时对象逃脱死亡的最后机会。GC 会对 F-Queue 中对象二次标记，如果此时与引用链上的任何对象建立了联系， 则会在二次标记时移除“即将回收”的集合。之后对象会再次出现没有引用存在情况时，finalize方法不会被再次调用，对象会直接变成不可触及状态。一个对象的 finalize 方法只会被调用一次




### 清除算法

- 当成功区分内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收， 释放掉无用对象占用的内存空间， 以便有足够的可用内存空间为新对象分配内存

- 常见的是: 标记-清除(MarkSweep)算法; 标记复制算法; 标记压缩算法

##### 标记清除算法

- 当堆中有效内存空间被耗尽时, 就会停止整个程序(STW), 然后进行标记和清除

  - Collector 从根节点开始遍历, 标记所有被引用的对象。一般是在对象的Header 中记录为可达对象
  - Collector 对堆内存从头到尾线性遍历，如果发现某个对象没有标记为可达对象，则进行回收

- 缺点
  - 效率不高
  - STW, 用户体验差
  - 清理出来的内存空间是不连续的，产生内存碎片，需要维护一个空闲列表

- 何为清除
  - 清除不是真的置空，需要把清除对象地址保存在空闲列表里，下次有新对象需要加载时, 判断垃圾位置空间是否足够，如果够，就存放

##### 复制算法(新生代使用效果较好)

- 将活着的内存空间分为两块, 每次只使用一块, 在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存块中, 之后清除正在使用的内存块中所有的对象，交换两个内存的角色, 最后完成垃圾回收

- 优点
  - 实现简单，运行效率高
  - 保证空间连续性，不会产生碎片

- 缺点
  - 内存使用率不高， 需要2倍的内存空间
  - 对于G1 拆分大量region 的GC, 复制而不是移动，GC 需要维护region 之间对象引用关系，不管时内存占用还是时间开销也不小

- 如果系统中垃圾对象很多，复制算法需要复制存活对象数量不大，或者非常低才行  

##### 标记压缩/整理算法(Mark-Compact)

- 背景
  - 复制算法的高效性建立在存活对象较少，垃圾对象多的前提下
  - 标记清除算法在老年代中效率低下，执行完还会产生内存碎片

- 第一阶段和标记清除算法一样，标记被引用对象
- 第二阶段将存活对象压缩到另一端，按序排放
- 之后清理边界之外的所有空间

- 优点
  - 消除 标记-清除里的缺点，没有内存碎片化
  - JVM只要一个内存起始地址
  - 消除复制算法内存代价

- 效率
  - 效率低于复制算法
  - 需要调整引用地址
  - SWT  


  ### 分代收集算法

  - 不同对象不同生命周期

  - CMS (Mark-Sweep)
    - Serial Old (Mark-Compact)

### 增量收集算法

- 每次垃圾收集线程只收集一小片区域，接着切换到应用程序线程，依次反复，知道垃圾收集完成
- 间断执行应用程序代码，线程上下文转换消耗，垃圾回收总成本上升，系统吞吐量下降

### 分区算法 (G1)

- 分隔若干个小区间, 减少GC 停顿
- 分区算法将整个堆划分成连续的多个小区间