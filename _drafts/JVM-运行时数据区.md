# JVM-运行时数据区

内存是非常重用的系统资源,是CPU和硬盘的中间仓库及桥梁

承载着操作系统和应用程序的实时运行.JVM 内存布局规定了java 在运行过程中的 申请,分配, 管理策略,保证JVM的高校稳定运行.

不同的JVM 对于内存的划分方式和管理机制存在着部分差异. (方法区有不同,J9 jRocket 没有方法区)

## 概述

### 线程使用的

- PC
- VMS (虚拟机栈)
- NMS (本地方法栈)

### JVM 公用的数据区

- 方法区 (5% GC , JDK8 MetaSpace)
- 堆 (95% GC)
-  代码缓存(JIT)

##  Thread

- 在HotSpot JVM里,每个线程都与操作系统的本地线程直接映射
- 当一个java线程准备好执行以后,此时一个操作系统的本地线程也同时创建. java 线程执行终止后, 本地线程也会回收
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上, 一旦本地线程初始化成功,它就会调用java线程中的run() 方法

### 后台线程

- 虚拟机线程: 需要JVM达到安全的出现.包括'stop-the-world' 的垃圾收集,线程栈收集,线程挂起以及偏向锁撤销
- 周期任务线程: 时间周期时间的体现(中断), 他们一般用于周期性操作的调度执行. 
- GC: 对JVM里不同种类的垃圾收集器行为提供了支持
- 编译线程: 将字节码编译成本地代码
- 信号调度线程: 接受信号给JVM, 在它内部进行了处理



###  Program Counter C Register (程序寄存器)

 并非广义上的物理寄存器, (PC 计数器, 程序钩子)

 PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码.由执行引擎读取下一条指令

- 很小的一块空间,几乎忽略不记,也是运行速度最快的存储区域

- 在JVM规范中,每个线程都有自己的程序计数器,是线程私有的,生命周期和线程生命周期一致

- 在任何一个线程都只有一个方法在执行,也就是**当前方法**. 程序计数器会存储当前线程正在执行的java方法的jvm指令地址; 或者如果是在执行native 方法,则是微指定值(undefined)

- 是程序控制流的指示器,分支,循环,跳转1,异常处理,线程恢复等基础功能都依赖它完成

- 字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令

- 它是唯一一个在JVM 规范中没有规定任何 OutOfMemoryError 情况的区域


```assembly
stack=2, locals=4, args_size=1

;指令地址,偏移地址: 操作指令  
0:bipush    10
2:istore_1
3:bipush    20
5:istore_2
6:load_1
7:load_2
8:iadd
9:istore_3
;#2 表示常量池数据
10:ldc    #2

```

 使用PC寄存器存储字节码指令地址有什么用? 为啥使用PC寄存器记录当前线程的执行地址

应为CPU需要不停的切换各线程, 切换回来以后需要知道从哪里开始继续执行.

 JVM的字节码解释器需要通过PC寄存器的值来明确下一条应该执行什么样的字节码指令

### 虚拟机栈

  由于跨平台性的设计,java 的指令都是根据栈来设计的. 不同平台CPU架构不同, 所以不能设计为基于寄存器的

  优点: 跨平台,指令集小,编译器容易实现.

  缺点: 性能下降,实现同样的功能需要跟多的指令

*栈(基本数据类型的局部变量)是运行时单位, 堆时存储单位*

##### JVM 栈

虚拟机栈是线程私有的,内部保存着一个个栈帧, 

一个栈帧对应着一次次方法调用,一个线程对应一个虚拟机栈

生命周期 和线程一致, 

主管java程序的运行,保存方法的局部变量, 部分结果,并参与方法的调用和返回

优点

- 栈是一种快速有效的分配存储方式,访问速度仅次于PC计数器
- JVM 直接对JAVA栈的操作只有两个:入栈,出栈
- 执行结束后的出栈操作
- 栈没有垃圾回收问题 (OOM, SOF)

栈(VMS)异常

java栈 的大小是动态的或固定不变的

- 如果是固定大小(-Xss : 设置栈大小), 每一个线程的VMS 可以在创建线程的时候独立选定.如果线程请求分配的栈容量超过VMS允许的最大容量,java 虚拟将会抛出一个StackOverFlowError 异常
- 如果VMS 可以动态扩展, 且在尝试扩展的时候无法申请到足够的内存,或者在创建新线程的时候没有足够的内存去创建虚拟机栈,那么会抛出 OutOfMemoryError 异常

-Xss size

 Linux (64bit : 1024k)

Windows: 默认值取决于VM大小

```bash
-Xss1m
-Xss1024k
-Xss1048576
```

##### 栈的存储单位

- 每个线程都有自己的栈, 栈中数据都是以栈帧(Stack Frame) 的格式存在
- 在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)
- 栈帧是一个内存区块, 是一个数据集,维系这个方法执行过程中的各种数据信息

###### 栈执行原理

- JVM对java 栈的操作只有入栈和出栈
- 在一个活动线程中, 一个时间点上, 只有一个活动的一个栈帧. 即只有当前正在执行的方法的栈帧(栈顶栈帧)是有效的, 这个栈帧被称为**当前栈帧(Current Frame)**, 与当前栈帧对应的方法就是**当前方法(Current Method)**, 定义这个方法的类就是**当前类**
- 执行引擎运行的所有字节码指令只对当前栈帧进行操作
- 如果该方法中调用了其他方法,对应的新栈帧会被创建出来,放在栈的顶端,成为新的当前栈帧
- 不同的线程中所包含的栈帧是不允许存在相互引用的,即不可能在一个栈帧之中引用另外一个线程的栈帧
- 如果当前方法调用了其他方法,方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧, 接着,虚拟机会丢弃当前栈帧1, 使得前一个栈帧重新成为当前栈帧
- Java 方法返回函数的方式,一种是正常的函数返回,使用return 命令; 另一种是抛出异常.不管使用哪种方式,都会导致栈帧被弹出

#### 局部变量表(Local Variables)

- 局部变量数组, 本地变量表
- **定义为一个数字数组(类型转换),用于存储方法参数和定义在方法体内部的局部变量**. 包括基本数据类型, 对象引用,以及returnAddress
- 由于局部变量表是建立在线程栈上, 是线程私有数,**因此不存在数据安全问题**
- **局部变量表所需的容量大小是在编译期确定下来的**, 并保存在方法的Code属性的maximum local variables 数据项中, 在方法运行期间是不会改变局部变量大小的.

- 方法嵌套调用的次数由栈的大小决定. 一般来说,栈越大,方法嵌套调用次数越多. 

  对一个函数而言, 它的参数和局部变量越多,使的局部变量表膨胀,它的栈帧就越大, 以满足方法调用所需传递的信息增大的需求.进而函数调用就会占用更多的栈空间,导致其嵌套调用次数就会减少

- 局部变量表中的变量只在当前方法调用中有效. 在方法执行时, 虚拟机通过使用局部变量表完成参数变量列表的传递过程. 当方法调研结束后, 随着方法栈帧的销毁, 局部变量表也会1随之销毁

###### Slot

- 参数值存放总是在局部变量数组的index0 开始, 到数组长度-1的索引结束

- 局部变量表,**最基本的存储单元是slot(变量槽)**

- 局部变量表中存放编译期可知的各种基本数据类型(8总), 引用类型(reference), returnAddress类型的变量

- 在局部变量表里, 32 位以内的类型只占用一个slot(包括returnAddress 类型), 64位的类型(long和double) 占用两个slot.

  byte ,short, char --> int ,boolean --> int,

  long double 占用2个slot

- JVM会为局部变量表中的每一个slot都分配一个访问索引, 通过这个索引即可访问到局部变量表中指定的局部变量值

- 当一个实例方法被调用的时候, 它的方法参数和方法体内部定义的局部变量会**按照顺序被复制**到局部变量中的每一个slot上

- 如果需要访问局部变量表中一个64bit的局部变量值时,只需要使用前一个(第一个)索引即可(比如访问long或double 类型变量)

- 如果当前帧是由构造方法,或者实例方法创建的,那么**该对象引用this 将会存放在index为0**的slot 处,其余的参数将按照参数表顺序继续排列

  ```java
  public static void methodA() {
      // 应为this 变量不存在于当前方法的局部变量表中
      System.out.println(this.field);
  }
  ```

- 槽位的重复利用: **栈帧中的局部变量表中的槽位是可以重用的**, 如果一个局部变量过了其作用域,那么在其作用域之后声明的局部变量就很有可能会复用过期的局部变量的槽位, 从而**达到节省资源的目的** 

```java
public void test() {
  int a = 0;
    {
      int b = 0;
      b = a + 1;  
    }
  // 使用之前变量b使用的槽位  
  int c = a + 1;
}
```


- 静态变量和局部变量的对比

    成员变量(类变量,实例变量)在使用前都经历过初始化赋值

    局部变量,在使用前必须显式赋值, 否则,编译不通过

- 在栈帧中,与性能调优关系最为密切的部分就是局部变量表.

  在方法执行时,虚拟机使用局部变量表完成方法的传递

- **局部变量表中的变量是重要的垃圾回收根节点(GC Root),只要被局部变量表中直接或间接引用的对象都不会被回收**


#### 操作数栈(Operand Stack) (表达式栈)

*可以通过数组或链表来实现*

- 每一个独立的栈帧中除了包含局部变量表以外,还包含一个先进后出的操作数栈, 也可以称之为表达式栈
- 操作数栈在方法执行过程中, 根据字节码指令,往栈中写入数据或提取数据,即入栈(push)/出栈(pop)
  - 某些字节码指令将值压入操作数栈,其余的字节码指令将操作数取出栈,使用他们后再把结果压入栈
  - 比如复制,交换,求和等操作
- 如果被调用的方法带有参数的话,其返回值将会被压入当前栈帧的操作数栈中,并更新PC 寄存器中下一条需要执行的字节码指令
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配,这由编译器在编译期间进行验证,同时在类的加载过程中类检验阶段的数据流分析阶段再次验证
- 另外,我们说JVM 解释引擎是基于栈的执行引擎,其中的栈指的就是操作数栈
- 操作数栈, **主要用于保存计算过程的中间结果,同时作为计算过程中变量临时的存储空间**
- 操作数栈就是JVM执行引擎的一个工作区,当一个方法刚开始执行的时候,一个新的栈帧也会随之被创建出来,**这个方法的操作数栈是空的**(但是长度是确定的)
- 每一个操作数栈都会有一个明确的栈深度用于存储数值,其所需的最大深度在编译期就定义好了, 保存在方法的code 属性中,为max_stack的值
- 栈中的任何一个元素都是可以任意的java 数据类型
  - 32bit 的类型占用一个栈单位深度
  - 64bit 的类型占用两个栈单位深度
- 操作数栈 **并非采用访问索引的方式来进行数据访问的**， 而是只能通过标准的入栈，出栈操作来完成一次数据访问

###### 栈顶缓存技术

- 基于栈式架构的虚拟机锁使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch) 次数和内存读写次数
- 由于操作数是存储在内存中的，因此频繁的执行读写内存操作必然会影响执行速度，为了解决这个问题， HotSpot JVM的设计者们提出了栈顶缓存(Tos, Top-of-Stack Cashing) 技术。**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**



#### 动态链接 (Dynamic Linking) (指向运行时常量池的方法引用)

*帧数据区： 包括动态链接，方法返回地址，附加信息*

- 每一个栈帧内部都包含一个指向**运行时常量池** 中**该栈帧所属方法的引用**，包含这个引用的目的就是为了支持当前方法的代码能够实现**动态链接** ，比如invokedynamic 指令
- 在java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如： 描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**



#### 方法的调用

- JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关
- 静态链接
  - 当一个字节码文件被装载进JVM 内部时，如果被调用的目标方法在编译器可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接

- 动态链接
  - 如果**被调用的方法在编译期无法被确定下来**，也就是说，只能够在程序运行期将调用方法的符号引用转化为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

对应的方法绑定机制：早期绑定(Early Binding) 和晚期绑定（Late Bind），绑定是一个字段，方法或者类在符号引用被替换为直接引用的过程，者仅仅发生一次

- 早期绑定
  - 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用 静态链接的方式将符号引用转换为直接引用
- 晚期绑定 （多态，虚函数）
  - 如果被调用的方法在编译期无法被确定下来，也能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定

- 非虚方法

  - 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可改变的，这样的方法称为**非虚方法**
  - 静态方法，私有方法，final 方法，实例构造器，父类方法都是非虚方法
  - 其他方法

  - 调用指令：

    - invokestatic(解析阶段唯一确定的方法版本)
    - invokespecial <init>方法，私有及父类方法，解析阶段唯一确定方法版本
    - invokevirtual调用所有虚方法（**final** 例外(不能被子类从写，但是使用super 显式调用后变成invokespecial)， ）
    - invokeinterface 调用接口方法

    *只要能被重写，都是虚方法*

  - 动态调用指令：invokedynamic: 动态解析需要调用的方法，然后执行

    - JVM字节码指令集一直比较稳定，直到java7 中才增加了invokedynamic 指令，这是**java 为了实现 [动态类型语言]支持而做*的一种改进*

    - 但是在java7 中并没有提供直接生成invokedynamic 指令的方法，需要借助ASM 这种底层字节码工具来产生invokedynamic 指令。**直到java8 的lambda表达式的出现，invokedynamic 指令的生成，在java中才有了直接生成方式**

    - java7 中增加动态语言类型支持的本质是对java 虚拟机规范的修改，而不是的java语言规则的修改

      增加 了虚拟机中的方法调用，最直接的受益者就是运行在java 平台的动态语言编译器

  - 虚方法表

    - 为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）使用索引表来替代查找
    - 每个类中都有一个虚方法表，表中存放各个方法的实际入口
    - 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕

#### 方法返回地址 (Return Address) (或方法正常退出或者异常退出的定义)

- 存放调用该方法的PC寄存器的值

- 一个方法的结束,有两种方式

  - 正常执行完成
  - 出现未处理的异常,非正常退出

- 无论通过那种方式退出, 在方法退出后都返回到该方法被调用的位置. 方法正常退出时,**调用者的pc 计数器的值作为返回地址,即调用该方法的指令的下一条指令的地址**. 而通过异常退出的,返回地址是要通过**异常表**来确定,栈帧中一般不会保存这部分信息

- 一个方法开始执行后,只有两种方式可以退出这个方法

  - 执行引擎遇到任意一个方法返的回字节码指令(?return), 会有返回值传递给上层的方法调用者,简称**正常完成出口**

    - 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定
    - 在字节码指令中,返回指令包含ireturn(当返回值是boolean, byte, char, short和int 类型时使用), lreturn, freturn, dreturn以及areturn, 另外还有一个return 指令供声明为void 的方法, 实例化初始化方法, 类和接口的初始化方法使用.
- 在方法执行过程中遇到了异常(Exception), 并且这个异常没有在方法内进行处理, 也就是只要在本方法异常表中没有搜索到匹配的异常处理器,就会导致方法退出, 简称**异常完成出口**

*区别在于: 通过异常完成退出的不会给他的上层调用者产生任何的返回值*




#### 一些附加信息



**五道面试题**

- 举例栈溢出情况
  - StackOverFlow
  - OutOfMemory
- 调整栈大小, 能保证不出现栈溢出么?
  - Xss: 
  - 不能, 如果是一个无法退出的递归方法
- 分配的栈内存越大越好么?
  - 不是,内存浪费
- 垃圾回收是否涉及 到虚拟机栈?
  - 不涉及
- 方法中定义的局部变量是否线程安全?
  - 看情况: 方法内部创建,内部消亡,则安全(逃逸分析)



### 本地方法接口

- 一个native 方法就是一个java 调用非java 代码接口,由非java 语言实现

- 与JAVA外环境交互: 与系统底层,或操作系统或某些硬件交换信息

- 与操作系统的交换: 与系统交换,甚至JVM 一部分就是C写的

- Sun's Java: Sun的解释器是用C实现的

  *现在的同构异构很发达*

#### 本地方法栈

- 本地方法栈管理本地方法的调用

- 本地方法栈也是私有的

- 允许被实现成固定或者可动态扩展的内存大小(内存溢出方面是相同的)

  - StackOverflow
  - OutOfMemoryError

- 本地方法是C语言实现的

- 具体做法是 Native Method Stack 中登记native 方法,在Execution Engine 执行时加载本地方法

- 当某个线程调用一个本地方法时, 它就进入了一个全新的并且不再受虚拟机限制的世界, 它和虚拟机拥有同样的权限

  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存堆中分配任意数量的内存

- 并不是所有的JVM 都支持本地方法. 因为java 虚拟机规范并没有明确要求本地方法栈使用的语言,具体实现方式,数据结构等. 如果JVM 产品不打算支持native 方法,也可以不实现本地方法栈

- 在HotSpot JVM 中,直接将本地方法栈和虚拟机栈合二为一

  