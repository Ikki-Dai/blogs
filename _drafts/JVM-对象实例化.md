# 对象实例化

## 方式
- new 运算符
  - xxx 静态方法
  - xxxBuilder/xxxFactory
- Class#newInstance(): 空参，权限public
- Constructor#newInstance(xxx): 有参，权限无要求

- clone(): 实现Cloneable接口
- 反序列化: ObjectInputStream
- 三方库 Objenesis

## 步骤
1. 判断对象对应的类是否加载，链接，初始化
2. 为对象分配内存 (计算对象占用空间大小，分配内存，如果是引用类型，仅分配引用大小： 4B)
  - 如果内存规整 --> 指针碰撞
  - 如果内存不规整: 虚拟机需要维护一个列表，空闲列表分配
  - 说明：哪种分配方式由垃圾回收器决定，标记清除算法规整

3. 处理并发安全问题
 - 采用CAS 配上失败重试保证跟新的原子性
 - 每个线程预先分配一块TLAB : -XX:+UseTLAB

4. 初始化分配到空间
 - 所有属性的默认值，保证对象实例字段不赋值时可以直接使用
  (属性默认初始化，零值初始化) 

5. 设置对象头
  - 指向方法区类元信息
  

6. 执行init 方法进行初始化
  - 显式初始化
  - 代码块初始化
  - 构造器初始化


## 对象访问定位

### 句柄访问
 - 本地变量表--> 句柄池(堆中) 
 - 句柄池(到对象实例数据的指针) --> 对象实例数据
 - 句柄池(到对象类型数据的指针) --> 对象类型数据

##### 优缺点
 - 不需要修改栈空间地址(标记回收算法)
 - 浪费内存

### 直接指针(Hotspot)
 - 本地变量表--> 对象实例数据(到对象类型数据的指针)
 - 对象实例数据(到对象类型数据的指针) --> 对象类型数据

 ## 直接内存

 - 不是虚拟机运行时数据区的一部分，也不是JVM规范中定义的内存区域
 - 直接内存是在堆外的，直接像系统申请的内存区间
 - 来源于NIO, DirectorByteBuffer 操作native 内存
 - 通常，操作直接内存速度，高于Java堆操作
   - 频繁读写场景 需要直接操作内存空间
   - JAVA允许java 使用直接内存

####
 - 也有可能导致OOM : OutMemoryError: Direct buffer memory
 - 不受限于 `-Xmx` 最大堆大小, 但仍然受限于系统内存
 - 缺点
   - 分配回收成本较高
   - 不受JVM 内存回收管理
 - 直接内存可以通过`MaxDirectMemorySize` 设置
 - 不指定，最大值和堆内存`-Xmx`值一致
